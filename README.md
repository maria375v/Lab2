# Lab2
#### № группы: `ПМ-2401`

#### Выполнил: Вялых Мария Викторовна

#### Вариант: `7`

### Cодержание:
- Постановка задачи
- Входные и выходные данные
- Выбор структуры данных
- Алгоритм
- Программа
- Математические формулы
- Анализ правильности решения

### 1. Постановка задачи
> Программа получает на вход натуральное число N, большее 1, не превышающее 100, 
> которое является количеством строк квадратной матрицы. Дается двумерный массив размером NxN,
> который заполняется с клавиатуры. Надо отсортировать массив по возрастанию количества гласных в столбце, 
> причем, если количество гласных одинаковое, то следует сортировать по возрастанию суммы ASCII-кодов
> символов. Затем надо вывести элемент(ы), который(ые) встречается(ются) чаще всего. После этого вывести 
> элементы массива в строку, двигаясь спирально против часовой стрелки, начиная с центрального элемента (если N нечётное) 
> или с любого из четырех центральных элементов (если N четное). 
> В данной программе реализуется алгоритм, выводящий элементы (при четном N) с нижнего правого из четырех центральных. 
> Затем надо в начальном отсортированном массиве изменить регистры букв на противоположный и вывести полученный массив.
 
Данную задачу можно разделить на 4 подзадачи: отсортировать столбцы по кол-ву гласных или по сумме ASCII-кодов символов, найти и вывести элемент, который встречается чаще всего, вывести элементы массива, двигаясь из центра по спирали против часовой стрелки, изменить регистры символов.
- Для 1 подзадачи нужно рассмотреть 2 случая:
    1. `Количество гласных разное`
    2. `Количество гласных одинаковое` (отрицание 1 случая)
- Для 4 подзадачи нужно также рассмотреть 2 случая:
    1. `У отдельного символа нижний регистр`
    2. `У отдельного символа верхний регистр` (отрицание 1 случая)
### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать число N, которое является размером квадратной матрицы. Нижняя и верхняя граница числа не указаны, но понятно, что число должно быть натуральны. По умолчанию верхнюю границу следует считать равной 100, нижнюю границу – равной 2.
Затем программа получает массив a[N][N] символов (буквы латинского алфавита) размером NxN.

|              | Тип                | min значение | max значение |
|--------------|--------------------|--------------|--------------|
| N (Число 1)  | Натуральное число  | 2            | 100          |
| a (Массив 1) | Массив с символами | A            | z            |

#### Данные на выход

Программа должна вывести несколько объектов. Отсортированный (по возрастанию кол-ва гласных или по возрастанию суммы ASCII-кодов) массив, элемент(ы), встречающийся(еся) чаще всего, последовательность элементов массива, которая выведена по спирали (против часовой стрелки), отсортированный массив с измененным регистром букв.

|                      | Тип                         | min значение | max значение |
|----------------------|-----------------------------|--------------|--------------|
| Массив 1             | двумерный массив символов   | A            | z            |
| Последовательность 1 | последовательность символов | A            | z            |
| Последовательность 2 | последовательность символов | A            | z            |
| Последовательность 3 | последовательность символов | A            | z            |

### 3. Выбор структуры данных

Программа получает одно натуральное число N (2<=N<=100) и массив размера NxN. Для их хранения можно выделить одну ячейку типа int и NxN ячеек типа char.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `N`                 | `int`        |
| a (Массив 1) | `a[i][j]`           | `char`       | 

Первый результат- новый массив, для него создается второй массив такого же размера, как и первый, второй результат- последовательность символов (количество от 1 до NxN включительно), третий результат- последовательность элементов массива, для вывода  необязательно создавать отдельный массив, четвертый результат-массив такого же размера, как и первый, для вывода необязательно создавать отдельный массив.

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает натуральное число N и двумерный массив размером NxN.

2. **Подсчет количества гласных:**  
    Программа считывает гласные в столбцах (через вложенный цикл for) и складывает их в отдельный массив. Затем элементы полученного массива сравниваются между собой (через вложенный цикл for), и если хотя бы два элемента совпадают, то программа считает сумму ASCII-кодов символов и складывает их в массив. Затем происходит сортировка либо по возрастанию кол-ва гласных, либо по возрастанию суммы ASCII-кодов символов в столбцах..

3. **Вывод элемента(ов), встречающегосе(ихся) чаще всего:**
       
    Программа складывает количество символов (не учитывая регистр) в ячейку, соответствующую номеру символа в алфавите (номер ячейки=номер символа+1, индекс ячейки=номер символа). Затем программа принимает за максимум кол-во повторений буквы а(А), затем, проходясь по массиву, отыскивает максимальное количество повторений элемента. Затем реализуется второй цикл, количество элементов сравнивается с максимумом, и если максимум совпадает со значением ячейки, то программа выводит символ, соответствующий индексу ячейки, увеличенному на единицу..

4. **Вывод в строчку, движение по спирали:**  
   Программа сначала идет по спирали с внешней стороны по часовой стрелке, закидывает элементы в строку, а потом переворачивает полученную строку. Сначала пробегаемся по строчке, потом по столбцу, затем вычитаем единицы, чтобы приблизиться к центру. Так бежим до тех пор, пока не выведем все символы..
5. **Вывод массива с измененным регистром:**
    Программа проходит по элементам массива (через вложенный цикл for), определяет регистр символа и меняет регистр (вычитает букву ‘a’ того же регистра, что и символ, потом прибавляет букву ‘a’ противоположного регистра). Затем элементы выводятся на экран.

### 5. Программа
```java
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;//для символьного типа даннных
public class Main {
    public static Scanner in = new Scanner(System.in); //для ввода данных
    public static PrintStream out = System.out; //для вывода данных
    public static void main(String[] args) throws IOException {
        int N=in.nextInt(); //кол-во строк и столбцов квадратной матрицы
        char [][] a=new char[N][N]; //создание и описание массива
        int [] b=new int[N]; //массив для кол-ва гласных
        char [][] c=new char[N][N]; //массив для отсортированных столбцов
        int [] s=new int[26]; //массив для подсчета кол-ва букв в массиве
        String ss=""; //для вывода символов по спирали по часовой стрелке
        String s1=""; //сюда переворачиваем строку ss
        int k=0; //кол-во гласных в массиве
        int m=0; //для перекидывания элементов массива
        int cn=0; //начало столбцов
        int ck=N-1; //конец столбцов
        int rk=N-1; //конец строки
        int rn=0; //начало строки
        int f=N*N; //кол-во символов в массиве
        int j1=0; //счетчик для цикла, который меняем вручную
        int pv=0; //индикатор (совпадает ли кол-во гласных в столбцах)
        for (int i=0;i<N;i++) { //бежит по строкам, потом по столбцам
            for (int j=0;j<N;j++) { //цикл для заполнения массива
                a[i][j]=(char) System.in.read(); //вводим символы
            }
        }
        for (int j=0;j<N;j++) { //пробегаемся, чтобы посчитать кол-во гласных в столбцах
            for (int i=0;i<N;i++) { //считаем столбцы, поэтому for'ы меняем местами
                if (a[i][j]=='a'||a[i][j]=='e'||a[i][j]=='i'||a[i][j]=='o'||a[i][j]=='u'||a[i][j]=='y'||a[i][j]=='A'||a[i][j]=='E'||a[i][j]=='I'||a[i][j]=='O'||a[i][j]=='U'||a[i][j]=='Y') {
                    k=k+1; //проверяем, гласная ли буква. Если да, то прибавляем счётчик
                }
            }
            b[j]=k; //закидываем в массив кол-во гласных в столбце
            k=0;//обнуляем, чтобы считать для другого столбца
        }
        for (int i=0;i<N;i++) { //цикл для массива с кол-вом гласных
            for (int j=i;j<N;j++) { //сортируем по возрастанию
                if (b[i]>b[j]) { // если элемент больше
                    m=b[i];
                    b[i]=b[j];//то меняем их местами
                    b[j]=m;
                }
            }
        }
        for (int i=0;i<N-1;i++) { //пробегаемся по массиву с кол-вом гласных
            for (int j=i+1;j<N;j++) {
                if (b[i]==b[j]) { //если кол-во гласных равно
                    pv=pv+1; //добавляем один к индикатору
                }
            }
        }
        if (pv>0) { //если кол-во гласных одинаковое
            for (int j=0;j<N;j++) { //пробегаемся по массиву
                k=0; //обнуляем счетчик
                for (int i=0;i<N;i++) {
                    k=k+(int)(a[i][j]); //считаем сумму кодов символов
                }
                b[j]=k; //закидываем в массив
            }
            for (int i=0;i<N;i++) {
                for (int j=i;j<N;j++) {
                    if (b[i]>b[j]) { //сортируем по возрастанию
                        m=b[i];
                        b[i]=b[j];
                        b[j]=m;
                    }
                }
            }
            for (int j=0;j<N;j++) {
                j1=j; //складываем индекс
                k=0;//обнуляем счётчик
                for (int i=0;i<N;i++) { //пробегаемся по массиву 
                    k=k+(int)(a[i][j]); //сумма кодов символов
                }
                for (int ib=0;ib<N;ib++) { //пробегаемся по массиву с суммой кодов
                    if (k==b[ib]) { //если сумма совпала со значением в массиве
                        for (int n2=0;n2<N;n2++) { //пробегаемся по начальному массиву
                            c[n2][ib]=a[n2][j1]; //в массив закидываем кол-во, если самое маленькое,
                        }//то оно попадёт в первый столбец, а если больше, то во второй и т.д.
                    }
                }
            }
        }
        else { //если кол-во гласных не повторяется
            for (int j=0;j<N;j++) {//пробегаемся по массиву
                j1=j; //запоминаем индекс
                k=0;//обнуляем счётчик
                for (int i=0;i<N;i++) {
                    if (a[i][j]=='a'||a[i][j]=='e'||a[i][j]=='i'||a[i][j]=='o'||a[i][j]=='u'||a[i][j]=='y'||a[i][j]=='A'||a[i][j]=='E'||a[i][j]=='I'||a[i][j]=='O'||a[i][j]=='U'||a[i][j]=='Y') {
                        k=k+1; //считаем кол-во гласных в столбцах
                    }
                }
                for (int ib=0;ib<N;ib++) {//пробегаемся по массиву с кол-вом гласных
                    if (k==b[ib]) { //если кол-вом совпадает
                        for (int n2=0;n2<N;n2++) { //пробегаемся по начальному массиву
                            c[n2][ib]=a[n2][j1]; //переставляем столбцы
                        }
                    }
                }
            }
        }
        for (int i=0;i<N;i++) { //пробегаемся по отсортированному массиву
            for (int j=0;j<N;j++) {
                out.print(c[i][j]+" ");//выводим его
            }
            out.println();//выводим в виде массива
        }
        for (int i=0;i<N;i++) { // пробегаемся по массиву
            for (int j=0;j<N;j++) { //будем искать элемент, который встречается чаще всех
                if ('a'<=a[i][j] && a[i][j]<='z') //если в нижнем регистре
                    s[(int)(a[i][j]-'a')]=s[(int)(a[i][j]-'a')]+1;//ячейка соответствует
                else //не важен регистр,заглавные в те же ячейки  //номеру в алф.-1
                    if ('A'<=a[i][j] && a[i][j]<='Z') //если в верхнем регистре
                        s[(int)(a[i][j]-'A')]=s[(int)(a[i][j]-'A')]+1; //заполняем ячейку
            }
        }
        int maxs=s[0]; //берём за максимум кол-во букв а
        for (int i=0;i<26;i++) { //пробегаемся по массиву
            if (s[i]>maxs) { //если какая-то буква встречается чаще
                maxs=s[i]; //принимаем кол-во этих букв за максимум
            }
        }
        for (int i=0;i<26;i++) { //снова пробегаемся по массиву
            if (s[i]==maxs) { //если какие-то буквы встречаются максимум раз
                out.println((char)(i+'a'));// выводим их
            }
        } //будем выводить спиралью, сначала не из центра и по часовой
        while(f>0){ //пока вывели не все элементы
            for(int i = cn; i <= ck && f>0; i++, f-- )//пробегаемся по первой строчке
                ss=ss+String.valueOf(a[rn][i])+" ";//закидываем символ в строку
            rn=rn+1; //прибавляем столбец       
            for(int i = rn; i <= rk && f>0; i++, f-- ) //пробегаемся по столбцу
                ss=ss+String.valueOf(a[i][ck])+" "; //закидываем символ в строку
            ck=ck-1; // прилбижаемся к центру       
            for(int i = ck; i >= cn && f>0; i--, f-- ) //по строке, в другую сторону
                ss=ss+String.valueOf(a[rk][i])+" "; //закидываем символ в строку
            rk=rk-1;//приближаемся к центру       
            for(int i = rk; i >= rn && f>0; i--, f-- ) //по столбцу, в другую сторону
                ss=ss+String.valueOf(a[i][cn])+" "; //закидываем символ в строку
            cn=cn+1; //идём дальше
        }
        for (int i=0;i<ss.length()-1;i++) { //пробегаемся по полученной строке
            s1=ss.charAt(i)+s1; //перевоорачиваем, закидывая в новую строку
        }// бежали до ss.length()-1, чтобы не было вконце пробела
        out.println(s1); //выводим элементы
        for (int i=0;i<N;i++) { //будем изменять регистр
            for (int j=0;j<N;j++) { //пробегаемся по массиву (начальному)
                if ('a'<=a[i][j] && a[i][j]<='z') { //если нижний регистр
                    a[i][j]=(char)(a[i][j]-'a'+'A'); //меняем
                    out.print(a[i][j]+" "); //сразу выыводим
                }
                else //иначе
                    if ('A'<=a[i][j] && a[i][j]<='Z') { //проверяем. Если верхний регистр
                        a[i][j]=(char)(a[i][j]-'A'+'a'); //меняем
                        out.print(a[i][j]+" "); //выводим
                    }
            }
        }
        
    }
}
```
### 6. Математические формулы
 - Изменение регистра. Вычитая из элемента букву а соответствующего регистра, мы получаем номер символа в алфавите (если элементы нумеруются с 0). Прибавляя букву а противоположного регистра, мы переходим на алфавит другого регистра и получаем символ, который нам нужен.

### 7. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Введем матрицу 3 на 3 с разным кол-вом гласных в строках и повторяющейся буквой о:

    - **Input**:
        ```
        3
        abc 
        eoy
        olu

        ```

    - **Output**:
        ```
        bca 
        oye 
        luo
        o 
        o e o l u y c b a
        A B C E O Y O L U

        ```

2. Введём матрицу 4 на 4 с буквами разных регистров без гласных:

   - **Input**:
       ```
       4
     M j B x
     P k C z
     Q l D w
     R n F v

       ```

   - **Output**:
        ```
        B M j x
        C P k z
        D Q l w
        F R n v
        b 
        c 
        d 
        f 
        j 
        k 
        l 
        m 
        n 
        p 
        q 
        r 
        v 
        w 
        x
        z 
        l D C k P Q R n F v w z x B j M
        m J b X p K c Z q L d W r N f V
        ```

3. Введем матрицу 2 на 2 с одной гласной с буквами разных регистров с двумя повторяющимися буквами:

    - **Input**:
        ```
        2
        A b b D
        ```

    - **Output**:
        ```
        b A
        D b
        b
        b D b A
        a B B d
        ```

4. Введем матрицу 3 на 3 с одними гласными с буквами разных регистров с повторяющимися буквами:

    - **Input**:
        ```
        3
      E o a
      e O a
      e o A
        ```

    - **Output**:
        ```
         a E o
         a e O
         A e o
         a 
         e
         o
         O e e o A a a o E
         e O A E o A E O a
        ```


